/* Domain geometry*/
real ROut = 10.0; // radius of outer circle
real RIn = 0.5*ROut; // radius of inner circle
/*Boudary condition for inner and ouetr circles*/
real uOut = 1.0;
real uIn = 2.0;
/*Mesh definition*/
int NN = 200;
int NOut = NN;
int NIn = int (RIn/ROut * NN);

int labelIn = 1; // Label of inner bound
int labelOut = 2; /* label of outer bound*/
/*Exact solution calculation*/
func uExactFunc = ((uIn - uOut)/log(RIn/ROut))*log(((x*x+y*y)^0.5)/ROut) + uOut;

/* inner circle bound definition */
border GammaIn(t = 0.0, 2.0*pi){
    x = RIn*cos(t);
    y = RIn*sin(t);
    label = labelIn;
}
border GammaOut(t = 0.0, 2.0*pi){
    x = ROut*cos(t);
    y = ROut*sin(t);
    label = labelOut;
}
plot(GammaOut(NOut) + GammaIn(NIn));
mesh Th = buildmesh(GammaOut(NOut) + GammaIn(-NIn));
plot(Th);


func real L2norm(real[int]& u) {
    real k = 0;
    for(int i = 0; i < u.n; i++) {
        k += u[i]*u[i];
    }
    return sqrt(k);
}

/*finite element space*/
fespace Vh(Th,P1); 
Vh uBigrad,uSolver,v; 
Vh uExact = uExactFunc;

/*bilinear form definiton for matrix*/
varf LaplaceBilinearForm(uSolver,v) = 

int2d(Th)(
    dx(uSolver)*dx(v) + dy(uSolver)*dy(v)
    ) 

+ on(labelIn,uSolver = uIn)
+ on(labelOut,uSolver = uOut);

varf RhsLinearForm(uSolver,v) =
   on(labelIn,uSolver=uIn) 
 + on(labelOut,uSolver=uOut);

plot (Th); 
matrix A = LaplaceBilinearForm(Vh,Vh, tgv = -1);/* Matrix creation*/
// Rhs creation
real[int] b = RhsLinearForm(0,Vh, tgv = -1);
/* BiCGStab */
int n = b.n;

real[int] x0(n);
x0 = 0.1;

real[int] x = x0; /* solution */

real[int] xPrevious = x0; /* solution on previout step */

real[int] r = A * x0; 
r = b - r;/* невязка */
real[int] rPrevious = r;

real[int] rtilda = r;

real rho = 1;
real rhoPrevious = rho;

real alpha = 1;
real alphaPrevious = alpha;

real omega = 1;
real omegaPrevious = omega;

real[int] v1(n);
v1 = 0;
real[int] vPrevious = v1;

real[int] p(n);
p = 0;
real[int] pPrevious = p;

real[int] s(n);
real[int] t(n);

real beta;
real eps = 1e-11;
real error = L2norm(r)/L2norm(b);

while (error > eps)  {

    rho = rtilda' * rPrevious;
    beta = (rho * alphaPrevious) / (rhoPrevious * omegaPrevious);
 //p = rPrevious + beta * (pPrevious - omegaPrevious * vPrevious)
    p = pPrevious - omegaPrevious * vPrevious;
    p = beta * p; 
    p = rPrevious + p; //базисный вектор подпространства Крылова

    v1 = A * p;
    
    alpha = rho / (rtilda' * v1);
    s = rPrevious - alpha * v1;
    t = A * s;
    omega = (t' * s)/(t' * t);
    x = omega * s + alpha * p;
    x = xPrevious + x;
    r = s - omega * t;
    rhoPrevious = rho;
    pPrevious = p;
    vPrevious = v1;
    alphaPrevious = alpha;
    xPrevious = x;
    rPrevious = r;
    pPrevious = p;
    omegaPrevious = omega;
    error = L2norm(r) / L2norm(b);
}

uBigrad[] = x;

load "MUMPS_seq"

real startTime = clock();
set (A,
    solver = sparsesolver, // for iterative solver,  UMFPACK - direct solver
    eps = 1e-7,// condition of exit
    strategy = 1 
);

uSolver[] = A^-1*b;

plot(Th, uSolver,wait = true, fill=true, dim=2, value=1, nbiso=100, cmm="MUMPS");
plot(Th, uBigrad, fill=true, dim=2,wait = true, value=1, nbiso=100, cmm="BiCGStab");
plot(Th, uExact, fill=true, dim=2,wait = true, value=1, nbiso=100, cmm="uExact");

cout << "Solve time " << clock() - startTime << endl;


Vh uSolverErrorAbs = abs(uSolver - uExact);
Vh uBigradErrorAbs = abs(uBigrad - uExact);

real uSolverError = sqrt(int2d(Th)(uSolverErrorAbs^2));
real uBigradError = sqrt(int2d(Th)(uBigradErrorAbs^2));

cout << "MUMPS_seq error = " << uSolverError << endl;
cout << "BiCGStab error = " << uBigradError << endl;
